"""Blender helper script for visualising Multiwfn critical points.

Run from Blender, for example:

    blender -b --python blenderp/cpview.py -- path/to/CPprop.npz --scale 0.25 --labels --render /tmp/cp.png

(-b for background mode)
The script expects an `.npz` archive generated by `multiwfn_cli cp2npz`.
"""

from __future__ import annotations

import argparse
import sys
from pathlib import Path
from typing import Dict

try:  # pragma: no cover - Blender provides these modules at runtime
    import bpy
    from mathutils import Vector
except ModuleNotFoundError:  # pragma: no cover - allows linting outside Blender
    bpy = None  # type: ignore[assignment]

    class Vector:  # type: ignore[no-redef]
        def __init__(self, iterable=(0.0, 0.0, 0.0)) -> None:
            self.x, self.y, self.z = iterable



BOHR_TO_ANGSTROM = 0.529177210903

DEFAULT_TYPE_COLOURS: Dict[str, tuple[float, float, float, float]] = {
    "(3,-3)": (0.90, 0.20, 0.20, 1.0),  # nuclear attractors
    "(3,-1)": (0.20, 0.40, 0.95, 1.0),  # bond critical points
    "(3,+1)": (0.20, 0.80, 0.35, 1.0),  # ring critical points
    "(3,+3)": (0.95, 0.85, 0.25, 1.0),  # cage critical points
}

TYPE_COLOR_LIST = [
    (DEFAULT_TYPE_COLOURS["(3,-3)"], "(3,-3)"),
    (DEFAULT_TYPE_COLOURS["(3,-1)"], "(3,-1)"),
    (DEFAULT_TYPE_COLOURS["(3,+1)"], "(3,+1)"),
    (DEFAULT_TYPE_COLOURS["(3,+3)"], "(3,+3)"),
]


def _parse_args(argv: list[str]) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Visualise Multiwfn CP data in Blender")
    parser.add_argument("npz_path", type=Path, help="Path to the CPprop .npz archive")
    parser.add_argument(
        "--collection",
        default="Critical Points",
        help="Name of the collection to (re)use for generated objects.",
    )
    parser.add_argument(
        "--scale",
        type=float,
        default=0.35,
        help="Radius of the CP spheres in Blender units (default: 0.35).",
    )
    parser.add_argument(
        "--labels",
        action="store_true",
        help="Add text labels showing the CP index above each sphere.",
    )
    parser.add_argument(
        "--clear",
        action="store_true",
        help="Remove any existing objects in the target collection before import.",
    )
    parser.add_argument(
        "--use-bohr",
        action="store_true",
        help="Interpret coordinates as Bohr instead of Angstrom (converted automatically).",
    )
    parser.add_argument(
        "--render",
        type=Path,
        metavar="OUTPUT",
        help="Write a rendered image to this path using Cycles with a transparent film.",
    )
    parser.add_argument(
        "--camera-distance",
        type=float,
        default=20.0,
        help="Multiplier applied to the CP cloud radius when positioning the camera (default: 20).",
    )
    parser.add_argument(
        "--legend",
        action="store_true",
        help="Add a simple colour legend parented to the camera.",
    )
    return parser.parse_args(argv)


def _load_npz(path: Path) -> dict:
    try:
        import numpy as np
    except ModuleNotFoundError as exc:  # pragma: no cover - Blender ships numpy, but guard anyway
        raise RuntimeError("numpy is required inside Blender to load CP data") from exc

    with np.load(path, allow_pickle=True) as data:
        return {key: data[key] for key in data.files}


def _ensure_collection(name: str) -> bpy.types.Collection:
    existing = bpy.data.collections.get(name)
    if existing:
        return existing
    collection = bpy.data.collections.new(name)
    bpy.context.scene.collection.children.link(collection)
    return collection


def _clear_collection(collection: bpy.types.Collection) -> None:
    to_delete = list(collection.objects)
    if not to_delete:
        return
    bpy.ops.object.select_all(action="DESELECT")
    for obj in to_delete:
        obj.select_set(True)
    bpy.context.view_layer.objects.active = to_delete[0]
    bpy.ops.object.delete()


def _activate_collection(collection: bpy.types.Collection) -> None:
    view_layer = bpy.context.view_layer

    def _recurse(layer_collection: bpy.types.LayerCollection) -> bool:
        if layer_collection.collection == collection:
            view_layer.active_layer_collection = layer_collection
            return True
        for child in layer_collection.children:
            if _recurse(child):
                return True
        return False

    _recurse(view_layer.layer_collection)


def _get_material(name: str, colour: tuple[float, float, float, float]) -> bpy.types.Material:
    material = bpy.data.materials.get(name)
    if material is None:
        material = bpy.data.materials.new(name=name)
        material.use_nodes = True
    if colour:
        if material.use_nodes and material.node_tree:
            principled = material.node_tree.nodes.get("Principled BSDF")
            if principled:
                principled.inputs["Base Color"].default_value = colour
                if len(colour) == 4:
                    principled.inputs["Alpha"].default_value = colour[3]
        material.diffuse_color = colour
    return material


def _colour_for_type(cp_type: str) -> tuple[float, float, float, float]:
    return DEFAULT_TYPE_COLOURS.get(cp_type, (0.75, 0.75, 0.75, 1.0))


def _ensure_camera() -> bpy.types.Object:
    scene = bpy.context.scene
    camera = scene.camera
    if camera is None:
        bpy.ops.object.camera_add(location=(0.0, -10.0, 5.0))
        camera = bpy.context.active_object
        scene.camera = camera
    return camera


def _setup_render_settings(output_path: Path) -> None:
    scene = bpy.context.scene
    output_path.parent.mkdir(parents=True, exist_ok=True)
    scene.render.engine = "CYCLES"
    scene.render.film_transparent = True
    scene.render.filepath = str(output_path)
    scene.render.image_settings.file_format = "PNG"
    scene.render.image_settings.color_depth = "16"
    scene.render.resolution_x = 1920
    scene.render.resolution_y = 1080
    scene.render.resolution_percentage = 100
    if hasattr(scene, "cycles"):
        scene.cycles.samples = max(scene.cycles.samples, 256)
        scene.cycles.use_adaptive_sampling = True


def _look_at(camera: bpy.types.Object, target: Vector) -> None:
    direction = target - camera.location
    if direction.length == 0:
        direction = Vector((0.0, 0.0, -1.0))
    quat = direction.to_track_quat("-Z", "Y")
    camera.rotation_euler = quat.to_euler()


def _align_camera_to_points(positions: list[Vector], distance_factor: float) -> None:
    if not positions:
        return
    camera = _ensure_camera()

    center = Vector((0.0, 0.0, 0.0))
    for pos in positions:
        center += pos
    center /= len(positions)

    max_radius = max((pos - center).length for pos in positions)
    distance = max(max_radius * distance_factor, 1.0)

    view_dir = Vector((1.5, -2.0, 1.2)).normalized()
    camera.location = center + view_dir * distance
    _look_at(camera, center)

    # adjust clipping planes to encompass scene
    camera.data.clip_start = 0.1
    camera.data.clip_end = max(distance * 4.0, 100.0)


def _extract_positions(data: dict, use_bohr: bool) -> tuple[list[Vector], str]:
    if "position_angstrom" in data and not use_bohr:
        coords = data["position_angstrom"]
        unit = "Å"
    elif "position_bohr" in data:
        coords_bohr = data["position_bohr"]
        if use_bohr:
            coords = coords_bohr
            unit = "Bohr"
        else:
            coords = coords_bohr * BOHR_TO_ANGSTROM
            unit = "Å"
    elif use_bohr and "position_angstrom" in data:
        coords = data["position_angstrom"] / BOHR_TO_ANGSTROM
        unit = "Bohr"
    else:
        raise RuntimeError(
            "The NPZ file does not contain 'position_angstrom' or 'position_bohr' fields."
        )

    vectors = [Vector((float(x), float(y), float(z))) for x, y, z in coords]
    return vectors, unit


def _create_label(text: str, location: Vector, collection: bpy.types.Collection) -> bpy.types.Object:
    bpy.ops.object.text_add(location=location)
    label_obj = bpy.context.active_object
    label_obj.data.body = text
    label_obj.data.align_x = "CENTER"
    label_obj.data.align_y = "CENTER"
    label_obj.data.size = 0.5
    if collection not in label_obj.users_collection:
        collection.objects.link(label_obj)
    for col in list(label_obj.users_collection):
        if col != collection:
            col.objects.unlink(label_obj)
    return label_obj


def _create_sphere(
    location: Vector,
    radius: float,
    material: bpy.types.Material,
    collection: bpy.types.Collection,
) -> bpy.types.Object:
    bpy.ops.mesh.primitive_uv_sphere_add(radius=radius, location=location)
    sphere = bpy.context.active_object
    sphere.data.materials.clear()
    sphere.data.materials.append(material)
    if collection not in sphere.users_collection:
        collection.objects.link(sphere)
    for col in list(sphere.users_collection):
        if col != collection:
            col.objects.unlink(sphere)
    return sphere


def _create_legend(collection: bpy.types.Collection) -> None:
    camera = _ensure_camera()
    legend_collection = bpy.data.collections.get("CP Legend")
    if legend_collection is None:
        legend_collection = bpy.data.collections.new("CP Legend")
        bpy.context.scene.collection.children.link(legend_collection)

    _clear_collection(legend_collection)

    base_x = 1.2
    base_y = -2.5
    base_z = 1.0
    spacing = 0.6

    for idx, (colour, label) in enumerate(TYPE_COLOR_LIST):
        offset = Vector((base_x, base_y, base_z - idx * spacing))

        bpy.ops.mesh.primitive_plane_add(size=0.35, location=(0.0, 0.0, 0.0))
        plane = bpy.context.active_object
        plane.name = f"CP_Legend_Patch_{label}"
        plane.parent = camera
        plane.matrix_parent_inverse = camera.matrix_world.inverted()
        plane.location = offset
        plane.rotation_euler = (0.0, 0.0, 0.0)
        mat = _get_material(f"Legend_{label}", (*colour[:3], 1.0))
        plane.data.materials.clear()
        plane.data.materials.append(mat)

        if legend_collection not in plane.users_collection:
            legend_collection.objects.link(plane)
        for col in list(plane.users_collection):
            if col != legend_collection:
                col.objects.unlink(plane)

        bpy.ops.object.text_add(location=(0.0, 0.0, 0.0))
        text_obj = bpy.context.active_object
        text_obj.name = f"CP_Legend_Label_{label}"
        text_obj.data.body = label
        text_obj.data.align_x = "LEFT"
        text_obj.data.align_y = "CENTER"
        text_obj.data.size = 0.35
        text_obj.parent = camera
        text_obj.matrix_parent_inverse = camera.matrix_world.inverted()
        text_obj.location = offset + Vector((0.45, 0.0, 0.0))
        text_obj.rotation_euler = (0.0, 0.0, 0.0)

        if legend_collection not in text_obj.users_collection:
            legend_collection.objects.link(text_obj)
        for col in list(text_obj.users_collection):
            if col != legend_collection:
                col.objects.unlink(text_obj)


def main(argv: list[str]) -> None:
    if "--" not in argv:
        print("Usage: blender --python blenderp/cpview.py -- <npz_path> [options]")
        return

    args = _parse_args(argv[argv.index("--") + 1 :])
    if not args.npz_path.exists():
        raise FileNotFoundError(f"NPZ file not found: {args.npz_path}")

    data = _load_npz(args.npz_path)
    positions, unit = _extract_positions(data, use_bohr=args.use_bohr)
    cp_types_array = data.get("cp_type")
    cp_types = [str(t) for t in cp_types_array] if cp_types_array is not None else []
    cp_indices_array = data.get("cp_index")
    cp_indices = list(cp_indices_array) if cp_indices_array is not None else []

    collection = _ensure_collection(args.collection)
    if args.clear:
        _clear_collection(collection)
    _activate_collection(collection)

    materials: Dict[str, bpy.types.Material] = {}

    for idx, position in enumerate(positions):
        cp_type = cp_types[idx] if idx < len(cp_types) else "unknown"
        mat_key = f"CP_{cp_type}"
        if mat_key not in materials:
            materials[mat_key] = _get_material(mat_key, _colour_for_type(cp_type))
        sphere = _create_sphere(position, args.scale, materials[mat_key], collection)
        sphere.name = f"CP_{idx+1}_{cp_type}"
        sphere["cp_type"] = cp_type
        if idx < len(cp_indices):
            sphere["cp_index"] = int(cp_indices[idx])

        if args.labels:
            label_text = (
                f"#{int(cp_indices[idx])} {cp_type}" if idx < len(cp_indices) else f"#{idx+1}"
            )
            offset_location = position + Vector((0.0, 0.0, args.scale * 2.0))
            label_obj = _create_label(label_text, offset_location, collection)
            label_obj.parent = sphere

    if args.legend or args.render:
        _align_camera_to_points(positions, args.camera_distance)

    if args.legend:
        _create_legend(collection)

    if args.render:
        _setup_render_settings(args.render)
        bpy.ops.render.render(write_still=True)

    print(
        f"Imported {len(positions)} critical points from {args.npz_path} "
        f"(coordinates in {unit})."
    )
    if args.render:
        print(f"Render saved to {args.render}")


if __name__ == "__main__":
    main(sys.argv)


