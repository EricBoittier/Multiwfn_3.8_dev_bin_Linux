"""Blender helper script for visualising Multiwfn critical points.

Run from Blender, for example:

    blender --python blenderp/cpview.py -- path/to/CPprop.npz --scale 0.25 --labels

The script expects an `.npz` archive generated by `multiwfn_cli cp2npz`.
"""

from __future__ import annotations

import argparse
import sys
from pathlib import Path
from typing import Dict

import bpy
from mathutils import Vector


BOHR_TO_ANGSTROM = 0.529177210903

DEFAULT_TYPE_COLOURS: Dict[str, tuple[float, float, float, float]] = {
    "(3,-3)": (0.90, 0.20, 0.20, 1.0),  # nuclear attractors
    "(3,-1)": (0.20, 0.40, 0.95, 1.0),  # bond critical points
    "(3,+1)": (0.20, 0.80, 0.35, 1.0),  # ring critical points
    "(3,+3)": (0.95, 0.85, 0.25, 1.0),  # cage critical points
}


def _parse_args(argv: list[str]) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Visualise Multiwfn CP data in Blender")
    parser.add_argument("npz_path", type=Path, help="Path to the CPprop .npz archive")
    parser.add_argument(
        "--collection",
        default="Critical Points",
        help="Name of the collection to (re)use for generated objects.",
    )
    parser.add_argument(
        "--scale",
        type=float,
        default=0.35,
        help="Radius of the CP spheres in Blender units (default: 0.35).",
    )
    parser.add_argument(
        "--labels",
        action="store_true",
        help="Add text labels showing the CP index above each sphere.",
    )
    parser.add_argument(
        "--clear",
        action="store_true",
        help="Remove any existing objects in the target collection before import.",
    )
    parser.add_argument(
        "--use-bohr",
        action="store_true",
        help="Interpret coordinates as Bohr instead of Angstrom (converted automatically).",
    )
    return parser.parse_args(argv)


def _load_npz(path: Path) -> dict:
    try:
        import numpy as np
    except ModuleNotFoundError as exc:  # pragma: no cover - Blender ships numpy, but guard anyway
        raise RuntimeError("numpy is required inside Blender to load CP data") from exc

    with np.load(path, allow_pickle=True) as data:
        return {key: data[key] for key in data.files}


def _ensure_collection(name: str) -> bpy.types.Collection:
    existing = bpy.data.collections.get(name)
    if existing:
        return existing
    collection = bpy.data.collections.new(name)
    bpy.context.scene.collection.children.link(collection)
    return collection


def _clear_collection(collection: bpy.types.Collection) -> None:
    to_delete = list(collection.objects)
    if not to_delete:
        return
    bpy.ops.object.select_all(action="DESELECT")
    for obj in to_delete:
        obj.select_set(True)
    bpy.context.view_layer.objects.active = to_delete[0]
    bpy.ops.object.delete()


def _activate_collection(collection: bpy.types.Collection) -> None:
    view_layer = bpy.context.view_layer

    def _recurse(layer_collection: bpy.types.LayerCollection) -> bool:
        if layer_collection.collection == collection:
            view_layer.active_layer_collection = layer_collection
            return True
        for child in layer_collection.children:
            if _recurse(child):
                return True
        return False

    _recurse(view_layer.layer_collection)


def _get_material(name: str, colour: tuple[float, float, float, float]) -> bpy.types.Material:
    material = bpy.data.materials.get(name)
    if material is None:
        material = bpy.data.materials.new(name=name)
        material.use_nodes = True
    if colour:
        if material.use_nodes and material.node_tree:
            principled = material.node_tree.nodes.get("Principled BSDF")
            if principled:
                principled.inputs["Base Color"].default_value = colour
                if len(colour) == 4:
                    principled.inputs["Alpha"].default_value = colour[3]
        material.diffuse_color = colour
    return material


def _colour_for_type(cp_type: str) -> tuple[float, float, float, float]:
    return DEFAULT_TYPE_COLOURS.get(cp_type, (0.75, 0.75, 0.75, 1.0))


def _extract_positions(data: dict, use_bohr: bool) -> tuple[list[Vector], str]:
    if "position_angstrom" in data and not use_bohr:
        coords = data["position_angstrom"]
        unit = "Å"
    elif "position_bohr" in data:
        coords_bohr = data["position_bohr"]
        if use_bohr:
            coords = coords_bohr
            unit = "Bohr"
        else:
            coords = coords_bohr * BOHR_TO_ANGSTROM
            unit = "Å"
    elif use_bohr and "position_angstrom" in data:
        coords = data["position_angstrom"] / BOHR_TO_ANGSTROM
        unit = "Bohr"
    else:
        raise RuntimeError(
            "The NPZ file does not contain 'position_angstrom' or 'position_bohr' fields."
        )

    vectors = [Vector((float(x), float(y), float(z))) for x, y, z in coords]
    return vectors, unit


def _create_label(text: str, location: Vector, collection: bpy.types.Collection) -> bpy.types.Object:
    bpy.ops.object.text_add(location=location)
    label_obj = bpy.context.active_object
    label_obj.data.body = text
    label_obj.data.align_x = "CENTER"
    label_obj.data.align_y = "CENTER"
    label_obj.data.size = 0.5
    if collection not in label_obj.users_collection:
        collection.objects.link(label_obj)
    for col in list(label_obj.users_collection):
        if col != collection:
            col.objects.unlink(label_obj)
    return label_obj


def _create_sphere(
    location: Vector,
    radius: float,
    material: bpy.types.Material,
    collection: bpy.types.Collection,
) -> bpy.types.Object:
    bpy.ops.mesh.primitive_uv_sphere_add(radius=radius, location=location)
    sphere = bpy.context.active_object
    sphere.data.materials.clear()
    sphere.data.materials.append(material)
    if collection not in sphere.users_collection:
        collection.objects.link(sphere)
    for col in list(sphere.users_collection):
        if col != collection:
            col.objects.unlink(sphere)
    return sphere


def main(argv: list[str]) -> None:
    if "--" not in argv:
        print("Usage: blender --python blenderp/cpview.py -- <npz_path> [options]")
        return

    args = _parse_args(argv[argv.index("--") + 1 :])
    if not args.npz_path.exists():
        raise FileNotFoundError(f"NPZ file not found: {args.npz_path}")

    data = _load_npz(args.npz_path)
    positions, unit = _extract_positions(data, use_bohr=args.use_bohr)
    cp_types_array = data.get("cp_type")
    cp_types = [str(t) for t in cp_types_array] if cp_types_array is not None else []
    cp_indices_array = data.get("cp_index")
    cp_indices = list(cp_indices_array) if cp_indices_array is not None else []

    collection = _ensure_collection(args.collection)
    if args.clear:
        _clear_collection(collection)
    _activate_collection(collection)

    materials: Dict[str, bpy.types.Material] = {}

    for idx, position in enumerate(positions):
        cp_type = cp_types[idx] if idx < len(cp_types) else "unknown"
        mat_key = f"CP_{cp_type}"
        if mat_key not in materials:
            materials[mat_key] = _get_material(mat_key, _colour_for_type(cp_type))
        sphere = _create_sphere(position, args.scale, materials[mat_key], collection)
        sphere.name = f"CP_{idx+1}_{cp_type}"
        sphere["cp_type"] = cp_type
        if idx < len(cp_indices):
            sphere["cp_index"] = int(cp_indices[idx])

        if args.labels:
            label_text = (
                f"#{int(cp_indices[idx])} {cp_type}" if idx < len(cp_indices) else f"#{idx+1}"
            )
            offset_location = position + Vector((0.0, 0.0, args.scale * 2.0))
            label_obj = _create_label(label_text, offset_location, collection)
            label_obj.parent = sphere

    print(
        f"Imported {len(positions)} critical points from {args.npz_path} "
        f"(coordinates in {unit})."
    )


if __name__ == "__main__":
    main(sys.argv)


